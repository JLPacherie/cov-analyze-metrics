// ****************************************************************************
//
// Requires Jenkins Plugins:
//
//  httpRequest 
//
//
// Requires access to AST Tools from /opt/synopsys
//
// Author: Jean-Lin PACHERIE, jean-lin.pacherie@synopsys.com
// ----------------------------------------------------------------------------
// Copyright (c) by Synospys, all right reserved.
// ----------------------------------------------------------------------------
//  THE SOFTWARE  IS PROVIDED "AS IS",  WITHOUT WARRANTY OF ANY KIND,  EXPRESS
//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE  AND NONINFRINGEMENT. IN NO EVENT SHALL 
//  THE AUTHORS OR COPYRIGHT HOLDERS BE  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
//  IN THE SOFTWARE.
// ****************************************************************************
import java.text.SimpleDateFormat
import groovy.time.TimeCategory 
import groovy.time.TimeDuration
import java.net.URLEncoder;

// ----------------------------------------------------------------------------
// Project Specific Configuration. Change this for each project.
// ----------------------------------------------------------------------------

// Plain name, all chars accepted.
def projectName="Coverity Analysis for Metrics"

// ID, no space allowed.
def projectUID="cov-analyze-metrics"

// This should match pom.xml version ?
def projectVersion="1.0.0"

// Main artefact to be generated by the build
def projectArtefact="target/cov-analyze-metrics-1.0.0-jar-with-dependencies.jar"

// Where to find the source code (Git Server)
def repoName='JLPacherie/cov-analyze-metrics.git'
def repoURL='https://github.com/' + repoName
def commit='master'

// Is there a specific Binary Artefect to scan ? Like a installer ?
def bdbaArtefact=""


// ----------------------------------------------------------------------------

// Docker Image for buiding this project
def dockerBuildImg='maven:3.6-jdk-11'
def mavenRepoCache="/opt/maven/repos"

// ----------------------------------------------------------------------------

// Coverity Stream Name for this project
def covStream="${projectName}"
def covAnalysisOptionDefault="--disable-fb --all --security --distrust-all --webapp-security"

def covMaxDefectRows=30

//
// Controls on Which Stages to Run
//

def doTesting=true
def doDeploy=true

//
// Pipeline Workspace Structure
//
def projectDir="project"
def synopsysDir="synopsys"

//
// Coverity Tool Configuration. Once for all projects.
//

def covLicense='/opt/synopsys/coverity/licenses/license-jenkins.dat'
def covVersion='last'

def covPath="/opt/synopsys/coverity/${covVersion}"

def covAnalysisPath="${covPath}/cov-analysis"
def covPlatformPath="${covPath}/cov-platform"
def covReportsPath="${covPath}/cov-reports"

def covIDir="${synopsysDir}/coverity/idir-build"
def covTempDir="${synopsysDir}/coverity/temp"
def covConfig="${synopsysDir}/coverity/config/cov-config.xml"
def covHost="82.64.26.142"
def covPort="35282"

// Those parameters are computed in the Gate stage
def covNewDefects=0
def covTotalDefects=0
def covNbLegacyDefects=0
def covNbUnclassified=0
def covNbCriticalPending=0
def covNbAgedDefects=0

//
// BlackDuck Binary 
//
def bdbaGroup=3
def bdbaAppName="${projectUID}"
def bdbaResponseFile="${synopsysDir}/bdba/responseFile.json"
def bdbaHost='http://82.64.26.142:35380'

//
// BlackDuck Hub / Detect 
//
def bdPath="/opt/synopsys/blackduck"
def bdHubURL="https://hubsig.blackducksoftware.com"
def bdReportFile="${synopsysDir}/blackduck/bd-spdx-report.xml"
def bdHubProjectName="${projectUID}"
def bdHubProjectVersion="${projectVersion}"
def hubBearer = ""       // If no Bearer is provided, then it wull be created from the BD_API_TOKEN
def hubProjectUID = ""   // If no HUB Project UID is provided, it will be retreived from project name
def hubProjectVersionUID = ""   // If no HUB Project version UID is provided, it will be retreived from project UID and verion name


// ----------------------------------------------------------------------------
// 
// ----------------------------------------------------------------------------
pipeline {

    agent any
    
    parameters {
        booleanParam(name: 'Incremental',
            defaultValue: true, 
            description: 'Specifies if the build is from a clean workspace or reuse previous')

        booleanParam(name: 'Coverity', 
            defaultValue: true, 
            description: 'Enable Scanning Source Code with Coverity  for Security and Quality Rule Issues')

        text(name: 'AnalysisOptions',
            defaultValue: "${covAnalysisOptionDefault}",
            description: "The analysis commandline options")

        booleanParam(name: 'BlackDuckSource', 
            defaultValue: true, 
            description: 'Enable Scanning Source Code with BlackDuck for Known Vulnerabilities & Licenses Issues')

        booleanParam(name: 'BlackDuckBinary', 
            defaultValue: true, 
            description: 'Enable Scanning Binary Target for Known Vulnerabilities')

        booleanParam(name: 'ComplianceGate', 
            defaultValue: true, 
            description: 'Check is AST Issues are still Compliant with Project Policies')

        string(name: 'ComplianceMaxDefects', 
            defaultValue: "30", 
            description: 'Specifies the Maximum Allowed Defects for a Build')

        string(name: 'ComplianceMaxNewDefects', 
            defaultValue: "10", 
            description: 'Specifies the Maximum Allowed New Defects in the Build')

        string(name: 'ComplianceMaxCriticalDefects', 
            defaultValue: "0", 
            description: 'Specifies the Maximum Allowed Critical (Penging and Severe) Defects in the Build')

        string(name: 'ComplianceMaxAgedDefects', 
            defaultValue: "3", 
            description: 'Specifies the Maximum Allowed Aged (Unresolved for too long) Defects in the Build')

        booleanParam(name: 'ComplianceBreakTheBuild', 
            defaultValue: true, 
            description: 'Specifies if the build should break if compliance gate failed.')
    }
    
    environment {
        HOME="${WORKSPACE}"
    }

    stages {
        

        // --------------------------------------------------------------------
        // Initialize Environment (Docker and co.)
        // --------------------------------------------------------------------
        stage('Init') {

            stages {
                stage("Workspace") {
                    steps {
                        script {

                            sh """#!/bin/bash
                                export PATH=\$PATH:${covAnalysisPath}/bin

                                if [ ! -d "$covPath" ]; then
                                    echo "Unable to find coverity dir at $covPath"
                                    exit -1
                                fi

                                mkdir -p "${covTempDir}"

                                if [ ! -f \"$covLicense\" ]; then
                                    echo "Unable to find license file at $covLicense"
                                    exit -1
                                fi

                            """
                        } // End of script
                    }
                }

                stage("Checkout Code") {
                    /*
                    when {

                    }
                    */
                    steps {
                        //
                        // Extract code from GitHub
                        //
                        
                        echo "Checkout SHA from reference $commit"
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: commit]],
                            //doGenerateSubmoduleConfigurations: false,
                            extensions: [
                                //[$class: 'CleanBeforeCheckout']
                                //[$class: 'CleanAfterCheckout'],
                                [$class: 'RelativeTargetDirectory', relativeTargetDir: projectDir]
                                //[$class: 'CloneOption', reference: "/opt/${repoName}"]
                            ],
                            submoduleCfg: [
                            ],
                            userRemoteConfigs: [
                                [
                                    //credentialsId: 'jenkins-git-credentials',
                                    url: repoURL
                                ]
                            ]
                        ])
                    } // End of steps
                } // 
            } // End of stages
        } // End of stage
        
        // --------------------------------------------------------------------
        //
        // --------------------------------------------------------------------
        stage("Build") {

            agent {
               docker {
                    image dockerBuildImg
                    // This is to make sure the container starts with 
                    // the same workspace (the one where config is created)
                    reuseNode true
                }
            }
            stages {


                stage ('Build Config') {
                    steps {
                        echo "Build Config Based on Toolchain defined inn ${dockerBuildImg}"

                        script {
                            sh """#!/bin/bash
                                export PATH=\$PATH:${covAnalysisPath}/bin

                                if [ ! -d "${mavenRepoCache}" ]; then
                                    echo "Error, no Maven Repos Cache folder found at ${mavenRepoCache}"
                                    exit -1
                                fi

                                mkdir -p "\$(dirname "${covConfig}")"
                                cov-configure --config "$covConfig" --java
                                cov-configure --config "$covConfig" --javascript

                                if [ -f "$covConfig/config.xml"  ]; then
                                    echo "Error, no Coverity Config found ar $covConfig"
                                    exit -1
                                fi
                            """
                        }
                    }
                }

                stage ('Incremental Build') {
                    
                    when {
                        allOf {
                            equals expected: true, actual: params.Incremental ;
                            expression { return fileExists(covIDir) } 
                        }
                    }

                    steps {

                        addBadge(text:"Incremental",icon: 'refresh.png')
                        echo "Performing an Incremental build"
                        script {
                            sh """#!/bin/bash
                                export PATH=\$PATH:${covAnalysisPath}/bin

                                mkdir -p "\$(dirname "${covConfig}")"
                                cov-configure --config "$covConfig" --java
                                cov-configure --config "$covConfig" --javascript

                                if [ -f "$covConfig/config.xml"  ]; then
                                    echo "Error, no Coverity Config found ar $covConfig"
                                fi

                                cov-manage-emit --dir "$covIDir" reset-host-name
                                cov-build --dir "$covIDir" --config "$covConfig" \
                                    mvn -Dmaven.repo.local="${mavenRepoCache}" -DskipTests -f "${projectDir}" install
                            """
                        }
                    }
                }

                // --------------------------------------------------------------------

                stage ('Full Build') {


                   
                    when {
                        anyOf {
                            equals expected: false, actual: params.Incremental ;
                            expression { return !fileExists(covIDir) }
                        }
                    }

                    steps {

                        // TODO Find a better icon for Full Build badge.
                        addBadge(text:"Full", icon: "refresh.png")
                    
                        script {

                            echo "Performing a FULL build"

                            sh """#!/bin/bash
                                export PATH=\$PATH:${covAnalysisPath}/bin
                                rm -Rf "$covIDir"
                                cov-build --dir "$covIDir" --config $covConfig \
                                    mvn -Dmaven.repo.local="${mavenRepoCache}" -DskipTests -f "${projectDir}" clean install
                            """
                        }
                    }
                }
            }

            //
            // After any of the build executed, keep the built artifact and Coverity build log
            //
            post {
               always {
                    archiveArtifacts artifacts: "${projectDir}/target/*.jar", fingerprint: true
                    archiveArtifacts artifacts: "${covIDir}/build-log.txt", fingerprint: true
                }
            }
        }
        
        // --------------------------------------------------------------------
        // This stage is for activating all AppSec Testing Tools
        // --------------------------------------------------------------------
        stage('AST Analysis') {
            parallel {
                stage ("Coverity") {

                    when {
                        equals expected: true, actual: params.Coverity 
                    }

                    stages {

                        stage ('Analysis') {

                            steps {
                                addBadge(text: 'Coverity', icon: 'coverity.png', link: 'http://82.64.26.142:35282/login/login.htm')


                                script {
                                    sh """#!/bin/bash
                                        export PATH=\$PATH:${covAnalysisPath}/bin
                                        cov-manage-emit --dir "${covIDir}" reset-host-name
                                        echo "${params.AnalysisOptions}" | xargs cov-analyze \
                                            --strip-path "\$(pwd)/${projectDir}/" \
                                            --security-file "$covLicense" \
                                            --dir "$covIDir" \
                                            --config "$covConfig"
                                    """
                                }
                            }
                        }

                        stage('Commit') {

                            steps {
                                withCredentials(
                                    [file(credentialsId: 'COVERITY_2019_06_API_KEY', variable: 'covApiKeyFile')]
                                )  {
                                        sh """#!/bin/bash
                                        export PATH=\$PATH:${covAnalysisPath}/bin
                                        
                                        mkdir -p "${synopsysDir}/coverity/reports"

                                        #
                                        # Extract JSON Report
                                        #
                                        cov-commit-defects --security-file "$covLicense" --dir "${covIDir}" \
                                            --host "${covHost}" --port "${covPort}" \
                                            --auth-key-file "${covApiKeyFile}" \
                                            --stream "${covStream}" \
                                            --preview-report-v2 "${synopsysDir}/coverity/reports/preview.json" 

                                        #
                                        # Commit Defects
                                        #
                                          cov-commit-defects --security-file "$covLicense" --dir "${covIDir}" \
                                            --host "${covHost}" --port "${covPort}" \
                                            --auth-key-file "${covApiKeyFile}" \
                                            --stream "${covStream}" \
                                            --version "${projectVersion}"

                                        """
                                }
                            }
                        }

                        stage('Reports') {
                            steps {
                                script {
                                    def jsonPreview = readJSON(file: "${synopsysDir}/coverity/reports/preview.json")

                                    def issueTable="""
                                    <table cellPadding="8" summary="defects">
                                      <thead bgColor="#4682B4">
                                        <th>CID</th>
                                        <th>Checker</th>
                                        <th>File</th>
                                        <th>Function</th>
                                        <th>Status</th>
                                      </thead>
                                      <tbody>
                                    """

                                    def nbIssues = jsonPreview.issueInfo.size()

                                    def currentDate = new Date();
                                    println "Current date : ${currentDate}"

                                    def datePattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
                                    def dateFormater = new java.text.SimpleDateFormat(datePattern);


                                    //echo "Nb Issues = ${nbIssues} "
                                    for (int iIssue = 0; iIssue < nbIssues && iIssue < covMaxDefectRows ; iIssue++) {
                                        

                                        def issue = jsonPreview.issueInfo[iIssue];

                                        if ( issue.triage.legacy == "True" ) {
                                            covNbLegacyDefects ++
                                        } else {
                                            covTotalDefects++
                                            issueTable = issueTable + "<tr bgcolor=\"#F8F8F2\" class=\"bodytextlarge\">"
                                            issueTable = issueTable + "<td>" + issue.cid + "</td>"
                                            issueTable = issueTable + "<td>" + issue.occurrences[0].checker + "</td>"
                                            issueTable = issueTable + "<td>" + issue.occurrences[0].file + "</td>"
                                            issueTable = issueTable + "<td>" + issue.occurrences[0].function + "</td>"

                                            //println "Detection date : ${issue.firstDetectedDateTime}"

                                            def firstDetected = dateFormater.parse(issue.firstDetectedDateTime);
                                            //println "Parsed date : ${firstDetected}"

                                            def  issueAge = new TimeCategory().minus(currentDate,firstDetected);

                                            println "Age : ${issueAge} and days = ${issueAge.days}"

                                            def status = "Known"

                                            if ( issue.presentInComparisonSnapshot == false ) {
                                                status = "New"
                                                covNewDefects ++
                                            } else if (issueAge.days.toInteger() >= params.ComplianceMaxAgedDefects.toInteger()) {
                                                status = "Aged";
                                                covNbAgedDefects++;
                                            } else {
                                                status = "Recent"
                                            }

                                            if (issue.triage.classification == "Unclassified") {
                                                covNbUnclassified++
                                            } 

                                            if ( (
                                                   (issue.triage.classification == "Unclassified") || 
                                                   (issue.triage.classification == "Pending")
                                                 ) &&
                                                 (
                                                    (issue.triage.severity == "Major") ||
                                                    (issue.triage.severity == "Moderate") 
                                                 )
                                                )
                                            {
                                                covNbCriticalPending++;
                                            }


                                            issueTable = issueTable + "<td>" + status + "</td>"

                                            issueTable = issueTable + "</tr>"
                                        }
                                    }

                                    if (nbIssues > covMaxDefectRows) {
                                        def missingRows = nbIssues - covMaxDefectRows 
                                        issueTable = issueTable + """
                                            <tr bgcolor="#F8F8F2" class="bodytextlarge">
                                                <td colspan=4>There are ${missingRows} more defects...</td>
                                            </tr>
                                        """
                                    }

                                    issueTable = issueTable + "</tbody>"
                                    issueTable = issueTable + "</table>"

                                    writeFile(file: "${synopsysDir}/coverity/reports/table.html", text: issueTable);

                                }
                            }
                        }
                    }
                    //
                    // After any of the build executed, keep the built artifact and Coverity build log
                    //
                    post {
                       always {
                            archiveArtifacts artifacts: "${covIDir}/output/summary.txt", fingerprint: true
                        }
                    }

               
                } 
                // --------------------------------------------------------------------

                stage("BlackDuck Source") {
                    agent {
                       docker {
                            image dockerBuildImg
                            // This is to make sure the container starts with 
                            // the same workspace (the one where config is created)
                            reuseNode true
                        }
                    }

                    when {
                        equals expected: true, actual: params.BlackDuckSource 
                    }

                    stages {

                        stage ("Analysis") {
                            steps {
                                withCredentials(
                                    [string(credentialsId: 'BLACKDUCK_API_KEY', variable: 'bdApiKey')]
                                )
                                {
                                    addBadge(text: "BlackDuck",icon: 'blackduck.png', link: 'https://hubsig.blackducksoftware.com/')
                                    script {
                                        sh """#!/bin/bash
                                            export PATH=\$PATH:${bdPath}/bin
                                            export HOME="\$(pwd)"
                                            detect.sh --blackduck.api.token="${bdApiKey}" \
                                                --blackduck.url="${bdHubURL}" \
                                                --detect.maven.build.command="-Dmaven.repo.local=/opt/maven/repos " \
                                                --detect.source.path="${projectDir}" \
                                                --detect.project.name=\"${bdHubProjectName}\" \
                                                --detect.project.version.name="${bdHubProjectVersion}" \
                                                --detect.output.path="${synopsysDir}/blackduck"

                                        """
                                    }
                                }
                            }
                        }

                        stage ("Reports") {
                            steps {
                                withCredentials( [string(credentialsId: 'BLACKDUCK_API_KEY', variable: 'bdApiKey')] )
                                {

                                    script {

                                        script {
                                            if (hubBearer == "") {
                                                def response = httpRequest(
                                                    url: "${bdHubURL}/api/tokens/authenticate",
                                                    httpMode: "POST",
                                                    customHeaders: [
                                                     [name: "Accept", value: "application/json"],
                                                     [name: "Authorization", value: "token ${bdApiKey}"]
                                                    ],
                                                    timeout: 2000
                                                )

                                                def jsonResponse = readJSON ( text: response.content)
                                                hubBearer = jsonResponse.bearerToken
                                            }
                                        }

                                        script {
                                            if (hubProjectUID == "") {
                                                def response = httpRequest(
                                                    url: "${bdHubURL}/api/projects?q=name%3A${bdHubProjectName}",
                                                    httpMode: "GET",
                                                    customHeaders: [
                                                     [name: "Accept", value: "application/vnd.blackducksoftware.list-1+json"],
                                                     [name: "Authorization", value: "bearer ${hubBearer}"]
                                                    ],
                                                    timeout: 2000
                                                )

                                                writeFile(file: "${synopsysDir}/blackduck/app.json", text: response.content, encoding: 'UTF-8' );

                                                def jsonResponse = readJSON(file: "${synopsysDir}/blackduck/app.json");

                                                def prjURL = jsonResponse.items[0]._meta.href
                                                hubProjectUID = prjURL.substring(prjURL.lastIndexOf("/")+1)
                                            }
                                        }
                                        echo "Found UID for project : ${hubProjectUID}"

                                        script {
                                            if (hubProjectVersionUID == "") {
                                                def response = httpRequest(
                                                    url: "${bdHubURL}/api/projects/${hubProjectUID}/versions/?q=versionName%3A${bdHubProjectVersion}",
                                                    httpMode: "GET",
                                                    customHeaders: [
                                                     [name: "Accept", value: "application/vnd.blackducksoftware.list-1+json"],
                                                     [name: "Authorization", value: "bearer ${hubBearer}"]
                                                    ],
                                                    timeout: 2000
                                                )

                                                writeFile(file: "${synopsysDir}/blackduck/version.json", text: response.content, encoding: 'UTF-8' );

                                                def jsonResponse = readJSON(file: "${synopsysDir}/blackduck/version.json");

                                                def versionURL = jsonResponse.items[0]._meta.href
                                                hubProjectVersionUID = versionURL.substring(versionURL.lastIndexOf("/")+1)
                                            }
                                        }
                                        echo "Found UID for version : ${hubProjectVersionUID}"

                                        def reportURL = ""
                                        /*
                                        script {
                                            def response = httpRequest(
                                                url: "${bdHubURL}/api/versions/${versionUID}/reports ",
                                                httpMode: "POST",
                                                contentType: "APPLICATION_JSON",
                                                customHeaders: [
                                                 [name: "Accept", value: "application/vnd.blackducksoftware.list-1+json"],
                                                 [name: "Authorization", value: "bearer ${hubBearer}"]
                                                ],
                                                timeout: 2000,
                                                requestBody: """
                                                {
                                                 "reportFormat" : "JSON",
                                                 "locale" : "en_US",
                                                 "versionId" : "${versionUID}",
                                                 "categories" : [ "SECURITY" ]
                                                }
                                                """
                                            )

                                            writeFile(file: "${synopsysDir}/blackduck/reportURL.json", text: response.content, encoding: 'UTF-8' );

                                            def jsonResponse = readJSON(file: "${synopsysDir}/blackduck/reportURL.json");

                                            reportURL = jsonResponse.items[0]._meta.href
                                        }
                                        */
                                        echo "Found URL for report : ${reportURL}"

                                    } // script
                                } // with credentials
                            } // steps
                        } // stages
                    } // stage
                    //
                    // After any of the SCA Analysis save the Vulnerability Report
                    //
                    post {
                       always {
                            archiveArtifacts artifacts: "${bdReportFile}", fingerprint: true
                        }
                    }


                } // End of BD Stage

                stage("BlackDuck Binary") {
                    when {
                        allOf {
                            equals expected: true, actual: params.BlackDuckBinary;
                            expression { return (bdbaArtefact != "") && fileExists(bdbaArtefact) } 
                        }
                    }
                    steps {
                        withCredentials(
                            [string(credentialsId: 'BDBA_API_KEY', variable: 'bdbaApiKey')]
                        )
                        {
                            addBadge(text: "BlackDuck",icon: 'blackduck.png', link: 'http://82.64.26.142:35380')

                            sh """#!/bin/bash
                                mkdir -p "\$(dirname ${bdbaResponseFile})"
                                echo "Uploading main artefact fro the project at ${bdbaArtefact}"
                                if [ ! -f "${bdbaArtefact}" ]; then
                                  echo "Error, missing file"
                                else
                                  ls -l ${bdbaArtefact}
                                fi
                            """
                            script {
                                def response = httpRequest(
                                    url: "${bdbaHost}/api/upload/${bdbaAppName}",
                                    acceptType: "APPLICATION_JSON",
                                    contentType: "APPLICATION_OCTETSTREAM",
                                    httpMode: "PUT",
                                    multipartName: "${bdbaAppName}",
                                    customHeaders: [
                                     [name: "Authorization", value: "Bearer ${bdbaApiKey}"],
                                     [name: "Group", value: "${bdbaGroup}"]
                                    ],
                                    uploadFile: "${bdbaArtefact}",
                                    timeout: 2000
                                )

                                writeFile(file: bdbaResponseFile, text: response.content, encoding: 'UTF-8' );

                                println('Status: '+response.status)
                                println('Response: '+response.content)
                            }
                        }
                    }

                    //
                    // After any of the build executed, keep the built artifact and Coverity build log
                    //
                    post {
                       always {
                            archiveArtifacts artifacts: bdbaResponseFile, fingerprint: true
                        }
                    }
                } // End of  BDBA Stage
            }
        }
         
        // --------------------------------------------------------------------
        // This stage if for Breaking the Build based on AST Findings
        // --------------------------------------------------------------------
        stage("AST Gate") {
            when {
                equals expected: true, actual: params.ComplianceGate 
            }

            steps {
                script {

                    //currentBuild.rawBuild.project.description = currentBuild.description
                    //currentBuild.rawBuild.project.save()

                    //def item = Jenkins.instance.getItemByFullName(env.JOB_NAME) 
                    //item.setDescription(currentBuild.description) 
                    //item.save()

                    def summary = createSummary(
                        icon: 'notepad.png', 
                        id: 'summary', 
                        text: '<h2>App Security Testing Gate</h2>')

                    // --------------------------------------------------------
                    // Coverity Reporting 
                    // --------------------------------------------------------
                    summary.appendText("""
                        <h3>Synopsys Coverity Defects</h3>
                    """)

                    if (params.Coverity) {
                        def covResume=readFile("${synopsysDir}/coverity/reports/table.html");
                        summary.appendText("""
                          Jump to Coverity Connect <a href="http://${covHost}:${covPort}">here</a> to see more about this project.
                          <table>
                          <tr>
                            <td>
                                <ul>
                                    <li>${covTotalDefects} total defects
                                    <li>${covNewDefects} new defects
                                </ul>
                            </td>
                            <td>
                                <ul>
                                  <li>${covNbLegacyDefects} legacy defects
                                  <li>${covNbUnclassified} untriaged defects
                                </ul>
                            </td>
                            <td>
                                <ul>
                                  <li>${covNbCriticalPending} critical and pending defects
                                  <li>${covNbAgedDefects} aged defects
                                </ul>
                            </td>
                          </tr>
                          </table>
                          ${covResume}
                        """,false)

                    } else {
                        summary.appendText("\n<it>Coverity Analysis Disabled</it>")
                    }

                    // --------------------------------------------------------
                    // BlackDuck Reporting 
                    // --------------------------------------------------------

                    summary.appendText("""
                        <h3>Synopsys BlackDuck Issues</h3>
                    """)

                    if (params.BlackDuckSource) {
                        def bdResume="""
                            Jump to BlackDuck Hub <a href="${bdHubURL}/api/projects/${hubProjectUID}/versions/${hubProjectVersionUID}/components">here</a> to see more about this project.
                        """
                        summary.appendText("""
                            ${bdResume}
                        """,false)
                    } else {
                        summary.appendText("BlackDuck Source disabled</it>")
                    }

                    if (params.BlackDuckBinary) {
                        summary.appendText("BlackDuck Binary enabled")
                    } else {
                        summary.appendText("BlackDuck Binary disabled")
                    }

                    // --------------------------------------------------------
                    // Evaluate Compliance Gate
                    // --------------------------------------------------------

                    def complianceGateMessage = "";
                    def complianceGateStatus = true;

                    // Option 1 : Simple Comliance
                    if (covTotalDefects > params.ComplianceMaxDefects.toInteger()) {
                        complianceGateStatus = false
                        complianceGateMessage += """<li><font color="red"><b>Too many new defects (${covTotalDefects} is above threshold of ${params.ComplianceMaxDefects})</b></font>"""
                    } else if (covTotalDefects > 0) {
                        complianceGateMessage += """<li><font color="#FF8C00">There's not enough Total defects to break this build (${covTotalDefects} is below threshold ${params.ComplianceMaxDefects})</font>""";
                    } else {
                        complianceGateMessage += """<li><font color="green">There's no defect at all</font>""";
                    }

                    if (covNewDefects > params.ComplianceMaxNewDefects.toInteger()) {
                        complianceGateStatus = false
                        complianceGateMessage += """<li><font color="red"><b>Too many new defects (${covNewDefects} is above threshold of ${params.ComplianceMaxNewDefects})</b></font>"""
                    } else if (covNewDefects > 0) {
                        complianceGateMessage += """<li><font color="#FF8C00">There's not enough new defects (${covNewDefects} is below threshold of ${params.ComplianceMaxNewDefects})</font>"""
                    } else { 
                        complianceGateMessage += """<li><font color="green">There's no New defects</font>""";
                    }

                    if (covNbCriticalPending > params.ComplianceMaxCriticalDefects.toInteger()) {
                        complianceGateStatus = false
                        complianceGateMessage += """<li><font color="red"><b>Too many critical defects (${covNbCriticalPending} is above threshold of ${params.ComplianceMaxCriticalDefects})</b></font>"""
                    } else if (covNbCriticalPending > 0) {
                        complianceGateMessage += """<li><font color="#FF8C00">There's not enough Critical defects to break this build (${covNbCriticalPending} is below threshold ${params.ComplianceMaxCriticalDefects})</font>""";
                    } else {
                        complianceGateMessage += """<li><font color="green">There's no Critical defects</font>""";
                    }

                    if (covNbAgedDefects > params.ComplianceMaxAgedDefects.toInteger()) {
                        complianceGateStatus = false
                        complianceGateMessage += """<li><font color="red"><b>Too many <em>Aged</em> defects (${covNbAgedDefects} is above threshold of ${params.ComplianceMaxAgedDefects})</b></font>"""
                    } else if (covNbAgedDefects > 0) {
                        complianceGateMessage += """<li><font color="#FF8C00">There's not enough Aged defects to break this build (${covNbAgedDefects} is below threshold ${params.ComplianceMaxAgedDefects})""";
                    } else {
                        complianceGateMessage += """<li><font color="green">There's no Aged defects in this build.""";
                    }

                    // --------------------------------------------------------
                    // Option 2 : SICM      
                    // --------------------------------------------------------

                    // --------------------------------------------------------
                    // Break the Build             
                    // --------------------------------------------------------

                    summary.appendText("""
                        <h2>Synopsys Compliance Gate</h3>
                        <ul>
                        ${complianceGateMessage}
                        </ul>
                    """)

                    if (!complianceGateStatus) {
                        currentBuild.description = "AppSec Gate Failed."
                        addBadge(text: "Failed", icon: 'error.gif')
                        if (params.ComplianceBreakTheBuild) {
                            error("Breaking Build on Compliance Failure")
                        }
                    } else {
                        currentBuild.description = "AppSec Gate Passed."
                        addBadge(text: "Passed", icon: 'success.gif')
                    }
                }

            }
        }

        // --------------------------------------------------------------------
        // This stage is for launching functional tests
        // --------------------------------------------------------------------
        stage("Test") {
            when {
                equals expected: true, actual: doTesting 
            }

            steps {
                script {
                    echo "Need to do some testing here"
                }


            }
        }

        // --------------------------------------------------------------------
        // Only for Release version, and if AST and functional tests passed
        // --------------------------------------------------------------------
        stage("Deploy") {
            when {
                equals expected: true, actual: doDeploy 
            }

            steps {
                script {
                    echo "Need to do some Deploy here"
                }


            }
        }

    }
}

