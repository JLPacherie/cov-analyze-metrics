#!/bin/bash
# *****************************************************************************
# cov-metrics-defects.sh
# 
#
# This script aims at creating defects for a code base already analyzed with
# Coverity. Function metrics are collected by Coverity and then compared to
# thresholds from a configuration file. Each time a metric value is above the
# configured threshold for a function, a new defect is created in a JSON file.
#
# Then the defects collected in the JSON file are published into the IDIR of
# code base (from which function metrics were extracted) for commiting.
#
# Usage:
#
# -----------------------------------------------------------------------------
# Author: Jean-Lin, Copyright 2016 (c) by Synopsys, all rights reserved
# *****************************************************************************

# Each time a variable is derefenced before being initialized, this raise an error
set -u

# The installation dir of the script.
ROOT_DIR=$(realpath $(dirname $0)/..)

# The binary (where is located this script)
BIN_DIR="$ROOT_DIR/bin"

# The configuration dir (with the checkers configs)
CONF_DIR="$ROOT_DIR/config"

# If multi processing is available, use all but one
nbProcs=$(( $(nproc) - 1))

# The intermediate directory from which metrics are extracted
# and defect published afterwards
IDIR=

OUTPUT_TAG=

# If path prefix has to be removed.
STRIP_PATH=""

# Where temporary files are created
TEMP_DIR=$ROOT_DIR/tmp

# Perform or not the integration of metrics defects in the IDIR
DO_IMPORT_DEFECTS=1

declare -A enabledCheckers;

BAD_CONFIG=0

# -----------------------------------------------------------------------------
assertRequire() {
  if [ -z "$(which $1)" ]; then
    echo "Configuration error, unable to find $1"
    exit -1
  fi
}

# -----------------------------------------------------------------------------

function showHelp() {
	echo \
"
 This script allows you to create defects from checkers based on code metrics
 as generated by Coverity during analysis.

 METRICS.CCM_TOO_HIGH
    This checker creates defects for functions with a CCM value higher than a
    threshold. Example : --add-threshold METRICS.CCM_TOO_HIGH=8
    Default threshold is 20

 METRICS.LOC_TOO_HIGH
    This checker creates defects for functions with a number of line of code
    higher than a threshold. Example : --add-threshold METRICS.LOC_TOO_HIGH=200
    Default threshold is 200

 You can add your own checker based on the function metrics computed by Coverity 
 from the template in <install-dir>/config

 Those checkers require that the code base had already been analyzed so that the
 function metrics are available from the intermediate directory.

 This script is provided AS IS without any warranty of <disclaimer to be completed later>

 --dir <idir_path>              Set the location of the intermediate directory
 --output-tag <tag>             Nam of the Coverity output tag
 --strip-path <path>            Remove file path prefix
 --enable-default               Enable all metric checkers
 --add-threshold checker=value  Set a checker's threshold
 --no-import                    Do not import found defects into intermediate directory
"
}
# -----------------------------------------------------------------------------

echo " "
echo "  ************************************"
echo "  ** Coverity Code Metrics Analyzer **"
echo "  ************************************"
echo " "
echo "  Author: Jean-Lin Pacherie, jpacher@synopsys.com"

# To retreive some stats from the IDIR
assertRequire cov-manage-emit

# To create a IDIR if not present
assertRequire cov-analyze

# Yo parse the FUNCTION.metrics.xml.gz file
assertRequire zcat
assertRequire xsltproc
assertRequire sed
assertRequire sort

# -----------------------------------------------------------------------------
# Read parameters from the command line

while [ $# -gt 0 ]; do


	case $1 in

    --dir|--idir) shift ; IDIR="$1" ;;
		--output-tag) shift ; OUTPUT_TAG="$1";;
		--strip-path) shift ; STRIP_PATH="$1";;

		--enable-default)
         enabledCheckers["METRICS.LOC_TOO_HIGH"]=200;
         enabledCheckers["METRICS.CCM_TOO_HIGH"]=20;
         ;;

    # Expected format:  --add-threshold CHECKER_NAME=Threshold
    # A configuration file is required in the config file.
    --add-threshold) shift ; 
         sep=$(expr index "$1" = ) ; 
         name=${1:0:$sep-1} ;
         value=${1:$sep} ;
         enabledCheckers[$name]="$value";;

    --no-import) DO_IMPORT_DEFECTS=0;;

    -j|--nb-procs) shift ; nbProcs="$1";;

		--help|-h) showHelp ; exit -1;;

		*) echo "Unknown option \"$1\", aborting." ; BAD_CONFIG=1;;

  esac

  shift

done;

# -----------------------------------------------------------------------------
# Check configuration parameters.
# -----------------------------------------------------------------------------

if [[ -z "$IDIR" ||  ! -d "$IDIR" ]]; then
	echo "Undefined intermediate directory. Use --dir <idir>"
	BAD_CONFIG=1
else
	echo " - Intermediate directory defined: $IDIR"
fi

FUNCTION_METRICS=$IDIR/output$OUTPUT_TAG/FUNCTION.metrics.xml.gz
if [ ! -f "$FUNCTION_METRICS" ]; then
	echo " - Unable to find function metrics at $IDIR/output$OUTPUT_TAG"
	BAD_CONFIG=1;
else
	echo " - Using function metrics at : $IDIR/output$OUTPUT_TAG"
fi


if [ ! -d "$TEMP_DIR" ]; then
	echo " - Creating missing temp dir at '$TEMP_DIR'"
	mkdir "$TEMP_DIR"
	if [ ! -d "$TEMP_DIR" ]; then
		echo "Unable to create temp dir at '$TEMP_DIR'"
		BAD_CONFIG=1
	fi
fi

# -----------------------------------------------------------------------------

nbCheckers=${#enabledCheckers[@]:-0}
if [ $nbCheckers -lt 1 ]; then
	echo " - There's no checkers defined, use option --enable-checker CHECKER_NAME=threshold"
	echo " - Available metrics checkers: "
	for file in $(ls "$CONF_DIR/METRICS".*.sh); do
		echo " - $(basename $file .sh)"
	done
	BAD_CONFIG=1
else
	echo ""
	echo " - There are $nbCheckers checkers defined."
  for checkerName in ${!enabledCheckers[@]}; do
  	echo "    $checkerName"
  done
fi

# -----------------------------------------------------------------------------

if [ $BAD_CONFIG -gt 0 ]; then
	echo "Aborting."
	exit -1
fi

# *****************************************************************************
# 
# *****************************************************************************


function getStripedPath() {
	if [ -z "$STRIP_PATH" ]; then
		echo "$1"
	else
		echo "$1" | sed "s#$STRIP_PATH##g"
	fi
}
# -----------------------------------------------------------------------------
# Extract the list of file to analyse
# -----------------------------------------------------------------------------

function getCoverityMetrics() {

	local output="$1"

	if [ -f "$FUNCTION_METRICS" ]; then

		# The XML metrics file is missing a root element for XSLT processing
		echo "<root>" > $TEMP_DIR/$$-rawmetrics.xml
		zcat "$FUNCTION_METRICS" >> $TEMP_DIR/$$-rawmetrics.xml
		echo "</root>" >> $TEMP_DIR/$$-rawmetrics.xml

		xsltproc "$BIN_DIR"/func-metrics.xsl $TEMP_DIR/$$-rawmetrics.xml | \
		  sed 's/,[ ]*fn:/,/g' | \
		  sed 's/,[ ]*/,/g'    | \
		  sed 's/;,/,/g'       | \
		  sed 's/;/,/g'       | \
		  sort -t, -k 1 > $TEMP_DIR/$$-rawmetrics.csv

		if [ "$TEMP_DIR/$$-rawmetrics.csv" != "$output" ]; then
			cp "$TEMP_DIR/$$-rawmetrics.csv" "$output"
		fi

	else
		echo "Unable to find $FUNCTION_METRICS" > /dev/tty
		exit -1
	fi
}

# *****************************************************************************
# 
# *****************************************************************************

# Cleanup local temp directory
rm -f "$TEMP_DIR"/*

# Extract function metrics from Coverity intermediate directory
echo " "
echo " - Extracting data from function metrics"
getCoverityMetrics "$TEMP_DIR/$$-tmp.csv"

# 
nbEntries=$(cat "$TEMP_DIR/$$-tmp.csv" | wc -l)

NB_TU=$(cov-manage-emit --dir "$IDIR" list | grep -v "Translation unit:" | wc -l)

echo "   There are $NB_TU translation units "
echo "   There are $nbEntries entries with collected data"
echo " "

echo '
{
	"header" : {
		"version" : 1,
		"format" : "cov-import-results input" 
	},
	
	"issues": [
	' > "$TEMP_DIR/$$-report.json"


allFilesFile="$TEMP_DIR/$$-allfiles.txt"
nbDefects=0
lineNum=0

#
# allDefect["checker_name"]=defect_count
declare -A allDefects
allDefects=()

# Loop over each line (e.g. function) from the Coverity metrics
while  IFS='' read -r strLine || [[ -n "$strLine" ]];  do

  let lineNum++

	#echo "In line $lineNum '$strLine'"

  #
  # Read the content of the CSV line into a Bash array
  #
	oldIFS=$IFS
	IFS=,	read -a arrayline<<<$(echo $strLine)
	IFS=$oldIFS

	if [ ${#arrayline[@]} -lt 3 ]; then
		echo "In line $lineNum '$strLine'"
		echo "Invalid statistics gathering, check $TEMP_DIR/tmp.csv"
	  continue
	fi

  #
  # Extract interesting attributes the metrics relate to
  #
  fileName="${arrayline[0]}"
  funcName="${arrayline[1]}"

  printf " (%3d %%) Processing $funcName                         \r" $(( 100 * lineNum / nbEntries ))

  #
  # Process extracted metrics with each of the enabled checkers
  #
  for metricName in ${!enabledCheckers[@]}; do

  	#
  	# Get the checker configuration
  	#
  	checkerThreshold=${enabledCheckers[$metricName]}
  	checkerScript="$CONF_DIR/$metricName.sh"

  	#
  	# Proceed with the checker
  	#
  	if [ -x "$checkerScript" ]; then

  		#
  		# If the checker found the function's metrics described in the
  		# Coverity calculation is above the configured threshold, then
  		# a new defect JSON text if generated in the format expected by
  		# cov-import-results.
  		#
	  	defectText=$($checkerScript "$strLine" $checkerThreshold  )

	  	if [[ ( $? == 0 ) && ( ! -z "$defectText" ) ]]; then

	  		# New defect found, counters are incremented
	  		let nbDefects++
  			allDefects[$metricName]=$(( ${allDefects[$metricName]-0} + 1))

	  		#echo $defectText | python -m json.tool

	  		# Deal with the separator in the JSON format for the list of
	  		# defect descriptors.
	  		if [ $nbDefects -gt 1 ]; then
	  			echo "," >> "$TEMP_DIR/$$-report.json"
	  		fi
	  		
	  		# Add the formated defect descriptor in the temp report.
	  		echo -n "$defectText" | jq .  >> $TEMP_DIR/$$-report.json

	  		# Add the source file where the defect is found in the list of files
	  		# if not already inserted in that list
	  		hasFile=""
	  		if [ -f ""$allFilesFile"" ]; then
		  		hasFile=$(grep "$fileName" "$allFilesFile")
		  	fi
		  	if [ -z $hasFile ]; then
		  		echo $fileName >> $allFilesFile
		  	fi

	  	fi
		else
			echo "Unable to find metric configuration for $metricName in $checkerScript"
			exit -1
		fi

  done

done < "$TEMP_DIR/$$-tmp.csv"

# End the list of defect in the JSON report
echo '],

' >> "$TEMP_DIR/$$-report.json"

printf " (100 %%) All $nbEntries functions processed                                    \n"

nbFiles=$(cat $allFilesFile | wc -l)

#
# If new files are found in the list then populate the JSON report with them
#
if [  $nbFiles -gt 0 ]; then

	echo '		"sources": [
		' >> "$TEMP_DIR/$$-report.json"

	fileListTemplate='{ "file": FILENAME , "encoding": "ASCII" }'
	iFile=0
	while IFS= read -r f ; do

		if [ $iFile -ge 1 ]; then
			echo "," >> $TEMP_DIR/$$-report.json
		fi

		fileName=$(echo "$f" | sed 's#\\#/#g')
		echo "$fileListTemplate" | sed "s#FILENAME#\"$fileName\"#g" | jq . >> "$TEMP_DIR/$$-report.json"

		let iFile++
	done < $allFilesFile

	echo ']' >> "$TEMP_DIR/$$-report.json"

fi
echo ' }
	' >> "$TEMP_DIR/$$-report.json"


printf " (100 %%) All $nbFiles files processed                                    \n"

# *****************************************************************************
# Write some nice stuff on the console to sumarize processing
# *****************************************************************************

echo ""
echo "Analysis results:"
for checkName in ${!allDefects[@]}; do
   printf "\t%4d %s\n" ${allDefects[$checkName]} $checkName
done

# *****************************************************************************
# ÃŽmport the metric defect in the intemediate directory
# *****************************************************************************

if [ "$DO_IMPORT_DEFECTS" == "1" ]; then

	echo "- Importing results into $IDIR/output$OUTPUT_TAG"
	jq . "$TEMP_DIR"/$$-report.json > "$IDIR/output$OUTPUT_TAG/defects-metrics-report.json"
	if [ $? = 0 ]; then

		ARGS=" "
		if [ ! -z "$OUTPUT_TAG" ]; then
			ARGS+=" --output-tag \"$OUTPUT_TAG\""
		fi

		if [ ! -z "$STRIP_PATH" ]; then
			ARGS+=" --strip-path \"$STRIP_PATH\""
		fi
		
		echo $ARGS | xargs cov-import-results \
			--dir "$IDIR" \
			--append \
			"$IDIR/output$OUTPUT_TAG/defects-metrics-report.json" > import-output.txt
		if [ $? != 0 ]; then
			echo "  !! Import failed."
		else
			echo "- You still have to commit defects." 
			echo "Done."
		fi
	else
		echo "JSON formating failed, Import aborted"
	fi

else
	echo "  - Defects are not imported into idir."
fi

exit 0
